# thinking
- LeetCode 的难度：
   - 简单，暴力可解的问题；
   - 中等，需要一个算法或数据结构优化时间、空间复杂度的题目；
   - 困难，需要两个或多个算法或数据结构组合优化时间、空间复杂度的题目
- 做题时可以先想出暴力解的思路，然后观察复杂度开销在哪里，当前题目是否有特性可以避开这个开销，再考虑如何优化。

  例如处理「链表排序」，我们知道排序算法有快排，时间复杂度为 `O(N*lgN)` ，但是因为链表查找效率为 `O(N)` ，所以该算法用于链表排序的复杂度变为 `O(N^2)` ，此时我们可以引入一个 `Map` 避免链表查找效率的开销，但这样引入了一个 `O(N)` 的空间复杂度开销。
换一个角度，是否有有不需要索引访问，而使用顺序访问的 `O(N*lgN)` 排序算法呢？答案就只有归并排序了，但是它也引入了一个 `O(N)` 的空间复杂度。

- 涉及到 `O(N)` 空间占用的题目，考虑是否需要完整存储所有信息，还是只需要存储上一个信息即可，最典型的便是状态压缩 DP。另一种情况是，有些链表或树的题目，我们需要知道当前节点的父节点是什么，但其实我们并不需要将其转换为双向链表、带父节点引用的树，而只是需要一个 `prev` 变量记录下上一次的节点是哪个即可

- 当使用到字符串子串的时候，可以不使用 s.slice 去真的获取子串，可以使用 left、right 标记子串的左右位置，节约空间与时间。

- 二叉搜索树（BST）的中序遍历就是有序输出
- 访问数组下标时候确认没有越界

- TopK 问题中，取最大的 K 个元素，需要维护一个 K 大小的**小顶堆**，堆顶元素即为 TopK 中的最小的那个元素。需要注意的是入堆操作：
   - 堆未满：追加数据到堆尾，然后上浮到合适位置
   - 堆满时：当待插入元素大于当前堆顶元素时，使用当前元素替换堆顶数据，然后下沉堆顶元素到合适位置
   - 对于堆排序问题，堆是无限大的，所以永远当做堆未满处理即可

- TopK 用堆 `O(NlgK)` ； `the k-th` 用快排思想 `O(lgN)`

- 可以用排序解题，而且允许额外空间的情况下，记得桶排序的 `O(N)` 复杂度，例如： [https://leetcode-cn.com/problems/longest-consecutive-sequence/solution/kong-jian-huan-shi-jian-by-a-bai-155-hnm5/](https://leetcode-cn.com/problems/longest-consecutive-sequence/solution/kong-jian-huan-shi-jian-by-a-bai-155-hnm5/)

- 递归问题记得先写**终止条件**和**基础解**，再写递归的部分

- 递归的优化：剪枝、备忘录

- 如果需要特殊处理链表的头节点，不妨设置一个新的头节点，将原头节点设置为这个新头节点的 next，这样就不需要特殊处理头节点了，但始终要记得真正的头节点是 lt19，删除倒数第 N 个节点

- 链表常用的几个变量，prev、cur、next，参考反转链表

- 为什么分治法时间复杂度低于遍历？参考主定理结论

- 拿到算法题的步骤：1. 确定题意、边界条件 2. 用case了解题目 3. 想思路，没思路情况可以先使用暴力解，再想暴力解中可以优化的部分 4. 编码 5. 验证编码，确定边界无问题

- 单调栈很好用


# 题目单
- 快排
- 堆排

# 复杂度计算
## 主定理