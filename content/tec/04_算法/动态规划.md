# 适用

**动态规划问题的一般形式就是求最值**。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求**最长**递增子序列呀，**最小**编辑距离呀等等。

动态规划的本质就是穷举，但是动态规划的穷举有点特别，因为这类问题**存在「重叠子问题」**，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。

而且，动态规划问题一定会**具备「最优子结构」**，才能通过子问题的最值得到原问题的最值。一般而言，原问题和子问题是可以递推的，直至子问题递推到基本情况，我们可以直接给出答案。


# 形式

动态规划只是一种思维方式与算法模式。具体的实现可以分为“自底向上（迭代+dp table）”和“自顶向下（递归+备忘录）”两种类型，其中 `dp table` 和 `备忘录` 是同一个东西，用处就是记录重复子问题的答案。他们都是实现动态规划的方法，并且本质上是相同的，毕竟，递归就是“迭代+栈”。

但从实现的角度上，递归方案需要额外的函数调用栈空间开销，相比之下，没有该开销的自底向上的迭代方法空间复杂度更优。但解题时还应看具体情况，有的问题用迭代方法很难求解，但递归方案很简单（例如树上的dp），此时还是应选择递归方案。


# 思考流程

1. 判断是否为动态规划问题，即上层问题是否可以通过求解子问题解决、子问题是否有重叠
2. 确定初始状态，即 `dp table` 的初始值
3. 明确变化的状态是什么，也就是原问题和子问题中会变化的变量。每一个状态就是一层迭代，也是 `dp table` 的一个维度。例如，零钱问题中的“剩余金额”
4. 明确 **选择** 是什么，即什么导致了状态的变化；有哪些选择，例如 戳气球 或 不戳
5. 明确 `dp table` 含义，初始化 `dp table` 。例如，零钱问题中表示“剩余金额”和“最少硬币数”的对应关系
6. 列出状态转移方程，即当前问题从上 N 个子问题如何推导出来


# 模板

- 自底向上的迭代模板
```javascript
// 以二维为例
// 1. init dp table
const dp = new Array(2).fill(0).map(item => new Array(2).fill(0));	// 注意不能直接new Array(2).fill(new Array(2))，js的问题

// 2. init dp table
dp = ...;

// 3. 循环状态，填充dp table，注意循环顺序
for (let state1 of states1){
  for (let state2 of states2){
    // 根据状态转移方程计算出当前一步的操作
    // 其中选择1、选择2等一般是已知的子问题答案加上一些计算的来的结果
  	const curResult = 求最值(选择1，选择2...);	
    dp[state1][state2] = curResult;	// 保存当前计算结果
  }
}

// 4. 取最后状态作为结果
return [states1.length-1][states2.length-1];	// 最后状态即为结果
```


- 自顶向下的递归模板
```javascript
/**
 * 递归dp模板
 * @param s {string} dp 问题中的字符串
 */
const func = function(s){
    const dp = new Array(s.length).fill(undefined);
    /**
     * @param s {string} dp 字符串
     * @param i {number} 索引 i
     * @param j {number} 索引 j
     */
    const impl = function(s, i, j){
        // 终止条件
        if (i > j){
            return 0;
        }
        // 记忆化搜索提取已经解决过的子问题
        if (dp[i][j] !== undefined){
            // 以 undefined 为判断标准是为了避免子问题解为 0 的情况导致重复计算
            return dp[i][j];
        }
        if (i === j){
            // 终止条件直接出结果并保存
            dp[i][j] = 'ANSWER';
        }else {
            let cur;
            // 样例，从子问题中选择期望的状态作为当前结果
            cur = Math.max(
                impl(s, i, j-1),
                impl(s, i+1, j),
            )
            dp[i][j] = cur;
        }

        return dp[i][j];
    }
    return impl(s, 0, s.length-1);
}
```


# 优化
状态压缩


# 常见 dp table 含义

- 字符串
   - `dp[i]`
      - 前 `i` 的字符构成的连续子串
      - 前 `i` 个字符构成非连续子序列：例如 lc 416.分割等和子集
      - 前 `i` 个字符构成的非连续子序列，且以第 `i` 个字符结尾，例如 lc 300.最长上升子序列
   - `dp[i][j]`: 一般出现在两个字符串题目中，例如最长公共子序列、正则表达式（lc 10）等
     - `str1` 的前 `i` 个字符构成的子串（子序列）和 `str2` 的前 `j` 个字符构成的子串（子序列）

- 背包
   - `dp[i][j]` 前 i 个商品，j 重量下的最大商品价值
   - `dp[i][j]` 前 i 个物品能否凑成总价 j



# 注意

1. 如果最终题目需要返回的值需要遍历 dp table 获取，则需要注意边界条件（尤其是起始条件）是否包含在内了。
1. 如果是二维dp，那么最好画出来表格，确定边界、目标和遍历的方向。

# 题目

- https://oi-wiki.org/dp/basic/