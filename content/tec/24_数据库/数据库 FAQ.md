# MySQL


## 基本的SQL语句，CRUD？设置索引？


- create
```sql
CREATE TABLE `media_birth_selected_0` (
	`id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '自增id',
	`album_id` bigint(20) NOT NULL COMMENT '宝宝相册ID',
	`media_id` bigint(20) NOT NULL COMMENT '照片ID',
	`score` double NOT NULL COMMENT '照片美学评分',
	`special_day_type` int(8) NOT NULL COMMENT '添加的日期类型:枚举->数值',
	`date_time` int(11) NOT NULL COMMENT '照片拍摄时间',
	`status` tinyint(4) NOT NULL COMMENT '状态：当前使用/可用/已被更换/源照片被删除',
	`rank` int(8) NOT NULL COMMENT '该条记录在[纪念日|节日|其他]中的级别',

	PRIMARY KEY (`id`),
	UNIQUE KEY `uk_mbs_id` (`album_id`, `media_id`),
	KEY `idx_mbs_tag` (`album_id`, `tag`),
	KEY `idx_mbs_rank` (`album_id`, `rank`, `date_time`, `score`),
	KEY `idx_mbs_status` (`album_id`, `status`, `date_time`, `score`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

- insert
```sql
insert into t (col1, col2) values (1, 2);
```

- update
```sql
update t set col1 = col1 + 1 where primary_key_id = 1234;
```

- delete
```sql
delete from t where primary_key_id = 1234;
```


## 三范式？


- 一范式：列是原子不可分的
- 二范式：有主键，保证完全依赖。每列都和主键相关，而不能只和主键的一部分相关
- 三范式：无传递依赖。每个列都是和主键直接相关的，而非间接相关



## MyISAM和InnoDB特点、区别、使用场景？
| 功能 | MyISAM | InnoDB |
| --- | --- | --- |
| 事务 | 不支持 | 支持 |
| 锁机制 | 表级锁 | 行级锁、间隙锁 |
| 外键 | 不支持 | 支持 |
| 适用场景 | 读多写少，不需要**事务**支持 | 需要**事务**支持 |



## 创建索引的SQL语句？实现方法？


`create index on table(column);`


对某列建立有序的数据结构，提高查询的更新的效率，但是相应的会因为维护索引导致插入删除性能有所降低。


MySQL创建索引其实就是创建了一个有索引结构的新表，然后把旧表数据复制过去，效率比较低。表数据量大的时候谨慎使用这个方法。


InnoDB使用B+tree实现索引，其他存储引擎还有Hash方法实现的索引（内存引擎）、全文索引等。


## 什么是聚簇索引？


索引键值的逻辑顺序与索引所服务的表中相应行的物理顺序相同的索引，被该索引称为聚集索引，反之为非聚集索引。InnoDB的主键是聚簇索引的。


## 什么是覆盖索引？

当索引中的内容覆盖了一个查询要查找的所有列，称这个查询使用了覆盖索引。这种情况下，数据库不需要通过查找到的主键值进行二次查找，而是可以直接从索引返回要查询的字段。

例如一张用户表`user`包含`name`, `age`, `icon`字段和`index(age, name)`索引，此时如果执行如下查询便可直接返回数据，不需要从次级索引查出主键后再回到聚簇索引上查询数据，但如果待查询字段加上`icon`就不可以了。

`select name, age from user where age = 22;`;


## 主键和唯一索引的区别？


主键是一个记录的唯一标识。一张表只能有一个主键。


唯一索引指的是其限定的列的取值不能出现冲突，但允许多个NULL。


主键和唯一索引区别主要有如下几点：


- 主键不允许NULL；唯一索引允许NULL，而且可以有多个NULL（在数据库中NULL和NULL不等，所以这不算破坏了唯一性）
- 一个表只能有一个主键而可以有多个唯一索引
- 从设计角度讲，主键用于唯一标志行，而唯一索引只是一种限定条件

## 哪些键适合建索引？

- 用于**查找**的建
- 用于**连接**的键
- 用于**排序**、**分组**的键

## 什么时候索引会失效？


- 以`%`开头的模糊匹配
- `OR`涉及到的列没有各自的索引
- 匹配的并非索引列本身，而是使用表达式、函数一类的计算值，例如`where col*2 <= 100`
- 要查询的数据量占据了全表的很大部分（20%以上）时，使用索引会带来大量的随机IO，此时MySQL会选择全表扫描的顺序IO
- 多个查询条件使用列未满足最左前缀索引的要求
- 范围匹配后的索引全部失效



## B树是什么？


B树是一棵多路平衡查找树，如果每个节点可以有最多m个子树，则其每个节点可以存储关键码数量的范围在`[m/2, m]`区间内，少于或超出会进行节点重组和拆分。这种设计保证了B树是平衡、数据有序的，并且树的高度相比二叉平衡树可以减少很多。


## B+树改进？这个索引结构为什么有效？

B+树其改进主要是如下几点：

- 所有的数据只存在于叶节点，非叶节点只存储关键码用于索引
- 叶节点是前后相连的，对应到全数据扫描的操作只需要遍历所有叶节点即可，而不用像B树一样深搜整棵树

B+树的一个叶节点一般被实现为一个页，页是在磁盘上一块连续的存储空间，这充分利用了磁盘I/O的顺序读取快而随机读取慢的特点。


## 什么是Hash索引？为什么InnoDB没有显式的Hash索引？


Hash索引是一个适用于随机访问的索引，不适合磁盘这类随机访问很慢但顺序访问较快的存储器，而是适合内存、固态硬盘这类存储器。


## 事务的四个基本特性？ ACID


- 原子性（Atomicity）：事务要么全部执行，要么全部不执行
- 一致性（Consistency）：事务执行前后的数据库完整性不会被破坏，例如银行存款总数不会改变
- 隔离性（Isolation）：多个事务之间是隔离的。一个事务不会看到另一个事务执行时的中间状态的数据。
- 持久性（Durability）：在事务完成后，事务对数据库所做的变更会永久写入数据库中，即使发生致命错误也不会丢失，且无法回滚



## 事务的隔离级别？


- Read Uncommitted：读未提交，可以读到其他事物的中间状态数据。产生“脏读”
- Read Committed：读提交，可在一个事务内多次读读到不同结果。避免“脏读”，产生“不可重复读”
- Repeatable read：可重复读。避免“脏读”、“不可重复读”，产生“幻读”
- Serializable：串行化，避免“脏读”、“不可重复读”、“幻读”

对几种读问题的解释：
- 脏读：会在一个事务内读到另外一个事务回滚之前修改的数据。如果出现脏读，那事务的隔离性已经没有得到保证
- 不可重复读：会在一个事务内的多次读取同一数据时读出不同的结果
- 幻读：事务A读取一些行时，事务B在该范围内插入了新行，事务A再次读取，结果与第一次读取不同，好像是幻觉一样，谓之“幻读”。


注意区分幻读与不可重复读，不可重复读对应**非结构性修改**，例如更新（update）；幻读对应**结构性修改**，例如插入（insert）与删除（delete）


## MVCC是什么？解决了什么问题？


## InnoDB插入数据时发生了什么？


## InnoDB如何保证事务持久性的？

// todo: redo log

## MySQL复制过程？


## drop、delete与truncate的区别


- drop会移除整张表，包括索引和权限。不能回滚，且不会触发任何DML触发器
- delete可以删除表中的任意多数据
   - 用户需要执行commite或rollback
   - delete会触发表上的触发器
- truncate清除表中所有数据但不移除表
truncate要比同样目的的delete快一些，但**不能回滚**，不会触发表上触发器。



## 什么是视图？


视图是虚拟的表，具有物理表的功能，可以插入、删除、修改等，但不能设置索引。


## 什么是游标？


查询返回行集，通过改变游标的位置查看行集中的具体行信息。


## 什么是触发器？


在满足某种条件时执行特定的语句序列，多用于保持数据库的完整性。

## `UNION ALL` / `UNION` 区别？

在明显不会有重复值时使用 UNION ALL 而不是 UNION

- UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作
- UNION ALL 不会再对结果集进行去重操作

## 如何修改大表的表结构？

考虑使用 `pt-online-schema-change`，或类似思路

核心在于：

- 避免大表修改产生的主从延迟
- 避免在对表字段进行修改时进行锁表

对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的。

`pt-online-schema-change` 会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。把原来一个 DDL 操作，分解成多个小的批次进行。


# Redis
## 常用数据结构，及其使用场景？
7 种：

- String
- Hash
- List
- Set
- ZSet
- Geo
- HyperLogLog

