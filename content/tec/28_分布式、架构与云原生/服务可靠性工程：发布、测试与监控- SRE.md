# 指导思想

## 软件生命周期

设计 -> 实现 -> 测试 -> 发布 -> 使用

大型软件系统生命周期的绝大部分都处于“使用”阶段，而非“设计”或“实现”阶段。

## 创新与稳定的互斥性

为了不出问题，运维角色通常会希望系统尽可能的减少变更，但是产品角色希望产品尽快迭代以适应市场需求，同竞品竞争。而 SRE 要做的，就是取其平衡，用其方法论与工程能力保障快速迭代产品的稳定性。

## 错误预算

错误预算：任何产品都不是，也不应该做到100%可靠（除了心脏起搏器和防抱死刹车系统等关键系统）。一般来说，任何软件系统都不应该一味地追求100%可靠。因为对最终用户来说，99.999%和100%的可用性是没有实质区别的。从最终用户到服务器之间有很多中间系统（用户的笔记本电脑、家庭WiFi、网络提供商和输电线路等），这些系统综合起来可靠性要远低于99.999%。所以，在99.999%和100%之间的区别基本上成为其他系统的噪声。就算我们花费巨大精力将系统变为100%可靠也并不能给用户带来任何实质意义上的好处。

“错误预算”就是“1-可靠性目标”。如果一个服务的可靠性目标是99.99%，那么错误预算就是0.01%。这意味着产品研发部门和SRE部门可以在这个范围内将这个预算用于新功能上线或者产品的创新等任何事情。

## 利用自动化消除琐事

琐事就是工程实践中手动性的，重复性的，可以被自动化的，战术性，没有持久价值的工作。而且，琐事与服务规模呈线性关系的增长。并不是每件琐事都有以上全部特性，但是，每件琐事都满足下列一个或者多个属性:

- 手动性
- 重复的
- 可以被自动化的
- 战术性的
- 没有持久价值
- 与服务同步线性增长

琐事不仅仅代表“我不喜欢的工作”。它也不能简单地等同于行政杂务加上其他脏活累活。每个人满意和喜欢的工作类型是不同的，有的人很喜欢手工的、重复性的工作。同时，一些管理类杂务是必须做的，不应该被归类为琐事: 这些是流程开销。流程开销通常是指那些和工程开发不直接相关的工作，包括团队会议、目标的建立和评估、每周总结以及人力资源的书面工作等。而具有长期价值的脏活累活也不能算作琐事。例如，为服务清理警报或者降低噪音率可能是一件繁重的工作，但这些不是琐事。

琐事经常是重要且紧急的，它占用工程师大量的时间。它经常突然出现，迫使工程师在休息时间低效加班。它扼杀工程师的创造力，改变工程师追求极致的态度，使工程师无法顾及业务和团队的目标，完全丧失了主动性。

琐事的完成不会对系统产生永久性的影响。例如，手动从数据库中关闭了一个异常订单属于琐事，因为之后还是会有类似的异常订单需要手动关闭。但是如果实现一个定时任务定时关闭异常订单，则可以消除对异常订单的手动操作，这就不属于琐事了。

## 留出 50% 的工作开发，而不是 all in 事故处理

用这 50% 的事件去自动化一些事情，而不是将全部身心投入到无穷无尽的告警与工单中。

## 三种监控类型

- 日志 logging
- 指标 metrics
- 链路 tracing

## SLI / SLO / SLA

SLI是指服务质量指标（Indicator）—该服务的某项服务质量的一个具体量化指标。大部分服务都将请求延迟—处理请求所消耗的时间—作为一个关键SLI。其他常见的SLI包括错误率（请求处理失败的百分比）、系统吞吐量（每秒请求数量）等。这些度量通常是汇总过的：在某一个度量时间范围内将原始数据收集起来，计算速率、平均值、百分比等汇总数据。

SLO是服务质量目标（Objective）：服务的某个SLI的目标值，或者目标范围。SLO的定义是SLI ≤ 目标值，或者范围下限 ≤ SLI ≤ 范围上限。例如，对莎士比亚服务来说，返回结果的速度应该是很“快”的，那么我们可以定义一个SLO，要求搜索请求的平均延迟小于100ms。

SLA是服务质量协议（Agreement）：指服务与用户之间的一个明确的，或者**不明确**的协议，描述了在达到或者没有达到SLO之后的**后果**。这些后果可以是财务方面的—退款或者罚款—也可能是其他类型的。区别SLO和SLA的一个简单方法是问“如果SLO没有达到时，有什么后果？”如果没有定义明确的后果，那么我们就肯定是在讨论一个SLO，而不是SLA。

我们不应该将监控系统中的所有指标都定义为 SLI；只有理解用户对系统的真实需求才能真正决定哪些指标是否有用。**指标过多会影响对那些真正重要的指标的关注**，而选择指标过少则会导致某些重要的系统行为被忽略。一般来说，四五个具有代表性的指标对系统健康程度的评估和关注就足够了。常见的服务，根据它们的相关SLI通常会归类为以下几个大类。
- 用户可见的服务系统，例如莎士比亚搜索服务的前端服务器通常关心可用性、延迟，以及吞吐量。换句话说：是否能正常处理请求？每个请求花费的时间是多少？多少请求可以被处理？
- 存储系统通常强调：延迟、可用性和数据持久性。换句话说：读写数据需要多少时间？我们是否可以随时访问数据？数据是否一段时间内还能被读取？扩展讨论参见第26章。
- 大数据系统，例如数据处理流水线系统，一般来说关心吞吐量和端到端延迟。换句话说：处理了多少数据？数据从输入到产出需要多少时间？（某些流水线任务还会关注某个单独处理阶段的延迟。）
- 所有的系统都应该关注：正确性。是否返回了正确的回复，是否读取了正确的数据，或者进行了正确的数据分析操作。正确性是系统健康程度的一个重要指标，但是它更关注系统内部的数据，而不是系统本身，所以这通常不是SRE直接负责的。

## 黄金指标及监控方式

对于任何对象，都可以考虑将这**四个黄金指标**设置为监控项：
- 延迟
- 吞吐量
- 错误
- 饱和度：所有有限资源，例如：CPU、MEM、连接数、线程池工作线程数等。99%的请求延迟（在某一个小的时间范围内，例如一分钟）可以作为一个饱和度早期预警的指标。

更具体的，可以考虑服务（及其依赖的下游服务）的这四大类指标：
- 计算：CPU 占用
- 存储：内存占用、硬盘占用
- 网络：网络上下行带宽占用
- 异常事件（错误）：重启、OOM、Core Dump

监控的视角分为外部视角和内部视角：
- 外部视角表示从客户端调用服务得到可用性，会受限于服务内部可用性、网络链路中任何一环、用户设备等，属于黑盒监控
- 内部视角指的是服务内部得到的可用性，等于成功请求/全部收到的请求，受到服务本身、依赖的下游服务、依赖组件等影响，属于白盒监控

不论是白盒监控还是黑盒监控，最好多花一些时间监控现象，而不是原因，因为可能导致异常现象的原因可能是无穷无尽的、不可枚举的。如果需要监控原因的话，应该只监控那些非常确定的和非常明确的原因。

## 系统的自愈能力

一个缓慢的不断重启的实例要好过一个永远不重启一直泄露资源的实例；一个死掉的服务好过一个瘫痪的服务。所以，最好的系统自愈方案不是去捕获种种异常并尝试处理（这也是不可能的），而是应彻底杀死异常的实例，并用新的实例取而代之。

## 监控系统只需要三种级别的输出

- 告警（需要介入人员脑力思考的异常才需要告警）

  告警一定是需要人工介入的问题，需要进行智力活动才能处理的问题。可以由系统自动处理的问题不应该发出告警，最多发出一条知会性质的消息。过多的无效告警会让开发者人员产生告警疲劳，从而忽略真正需要人工介入的告警。

  同理，业务监控指标的阈值配置也应合理，避免产生过多的伪告警。例如，有些业务逻辑会导致 CPU 短时内飙高，但是实际上是正常的业务负载，这是如果过于敏感地监控指标，则会产生大量的伪告警。

  高效的警报系统应该提供足够的信息，并且误报率非常低。

- 工单（天级别处理）
- 日志

# 实践

# Ref

- [Google SRE](https://book.douban.com/subject/26875239/)
- [Google Cloud - DevOps 衡量：监控和可观测性](https://cloud.google.com/architecture/devops/devops-measurement-monitoring-and-observability?hl=zh-cn)