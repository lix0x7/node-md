# 概览

本文主要介绍传统搜索的内容，即基于 elasticsearch、lucene、分词等技术构建的搜索系统，不包含向量检索、大语言模型、RAG 等技术。

其主体流程如下：

// todo: insert procedure image here

技术架构如下：

// todo: insert architecuture image

# 召回流程

## NLU、扩召回

搜索最前置的阶段是对用户的 query 词进行处理，通过原始 query、纠错、扩召回等方式优化搜索效果，这里包括如下一些策略：
1. 语义分词
2. 同义词：搜索「腾讯创始人」，扩召回补充上「马化腾」
3. 纠错：例如「帐单」，纠错召回补充「账单」
4. 补充向量召回：将 query 词转换为 embedding，并发起向量召回辅助搜索

## 召回

一句话：从 Elasticsearch 中获取数据的过程称为「召回」。召回的过程就是根据用户的 query 和预定义的召回策略，拼接符合语义的 DSL，送到索引中获取到业务数据。

为了保证后续排序质量，一般召回阶段都会提前召回大量的数据，但其中大部分不会直接返回给用户，而只是用于排序。例如用户最终能看到 15 条数据，但召回阶段会召回200条以上的数据。

其中召回策略分为如下这些逻辑部分：
0. 权限：必备的部分，例如：用户仅可搜索自己有权限的文档
1. 用户筛选器：用户指定的筛选器，例如只搜离职人员
2. 召回策略：搜索策略，例如人名可搜、人名拼音可搜
3. 提权策略：对于特定的情况（例如拼音完全匹配），将其权重大幅度提高。

举个例子：
```json
{
    "query":{
        "filter": [
            // 权限：只搜当前用户租户的数据
            {
                "term": {
                    "tenant_id": "1234"
                }
            },
            // 用户筛选器：只搜离职人员
            {
                "term": {
                    "status": "resigned"
                }
            }
        ],
        // 召回策略
        "should": [
            {
                "match_phrase": {
                    "name.ngram": "诸葛亮" // 通过ngram达成类似模糊搜索的效果
                    "analyzer": "ngram"
                },
                "term": [
                    {
                        "name.pinyin": "zhugeliang", // 通过拼音的keyword检索达成拼音搜索的目的，该数据在索引时写入
                        "analyzer": "keyword", // 不对query进行分词
                    }, 
                    {
                        // 提权策略
                        // 完全命中了字段拼音
                        "name.pinyin_keyword": "zhugeliang",
                        "analyzer": "keyword",
                        "boost": 5
                    }
                ]
            }
        ]
    }
}
```

### 分词能力

常见的分词器包括：
- 拼音：常用于短文本拼音，类似人名、地名等，例如「马化腾」会被索引为 `mahuateng mht mh m ma mah mahua mahuat mahuate mahuaten`，召回阶段使用 `keyword`
- 简繁转换
- 单字拆分：常配合 phrase 实现模糊检索的效果，不适用于长文本，「北京大学」会被索引为「北京、大学」，召回阶段使用 `match_phrase`
- ik：长文本语义分词
- 驼峰、蛇形分词
- 前缀分词
- 后缀分词：常用语手机尾号、身份证尾号检索

## 粗排

所谓「粗排」就是召回阶段的排序，一般是通过 ES 的排序能力来实现的。粗排可分为几种类型：文本相关性、时间、固定提权、固定降权、衰减（decay）。

## 精排

除了在粗排中可以完全独立地进行一次排序，当前用户看到的数据优先级也大多和用户特征有关，典型的几个提权的场景：
- 用户搜索了一个自己前几个小时频繁打开的文档
- 用户搜索了最近经常发言的群聊
- 用户搜索了自己的直属 leader，尽管该 leader 有很多同名联系人，但因为组织架构关系，用户 leader 仍然应排在搜索结果的第一

这些 case 都有典型的特征，以至于不易在粗排阶段完成：
- 依赖了外部特征，包括组织架构信息、数据埋点等
- 和搜索者相关

当然，我们也可以把外部特征引入到索引内，然后通过复杂的 DSL 语句达成同样的效果，但是这对索引要求太高了，他必须存储很多和待索引数据无关的信息、需要频繁的更新、DSL 也会变得十分复杂。

所以，大多情况下，我们都会通过独立的程序实现上述复杂上下文的排序逻辑，这个过程称为「精排」。

## 分页与缓存

分页的主要功能是将排序后全量数据进行切片，将用户需要的部分数据返回。例如 200 条数据精排后送入分页阶段，只有前 15 条用户最需要的数据会返回，其余的则忽略。

这里有一个问题，考虑到如下问题，精排产出的数据应该被缓存以供后续翻页使用：
- 每一次召回和排序并不稳定：即使是完全相同的查询，也会因为索引数据变化、特征变化产生不同的召回结果
- 性能问题：召回、排序都是高性能开销的步骤，为了节约资源，可以通过缓存规避重复计算

仍然以 200 条召回数量、15 条每页来计算，理想情况下这 200 条数据足够用户翻页 13 次了，足以覆盖大多数搜索场景。
一般而言，如果用户通过前三页都没有搜到自己想要的东西，会尝试细化搜索词、筛选条件来达成目的，而非无目的的无限翻页。

## 后置鉴权

如果用户搜索了一些系统外数据，但此类数据权限又有较为特殊的规则，需要对最终返回给用户的数据进行鉴权，保证数据安全。
此处搜索系统发起请求至业务系统，业务系统返回特定 id 对当前用户的鉴权结果。搜索将其中不满足要求的结果过滤掉。

需要注意的是，后置鉴权是一种兜底方案，为了确保 100% 的安全，分页后的数据被过滤会导致一页数据不完整，用户可能可以观察到数据缺失，从而影响用户体验。理想情况下后置过滤的比例应该尽可能地低。如果比例过高，需要考虑将其前置到召回阶段的前置鉴权部分完成。

## 打包

将最终要返回客户端的数据打包为客户端需要的形式，这个阶段涉及到外部数据的填充与不同结构体间的转换。例如搜索联系人并返回给端上前，需要填充对应的头像 url，则在该阶段通过组织架构服务将其头像链接填充到返回体上，最终传回给客户端渲染。

# 写入流程

写入是搜索的前置过程，在用户触发搜索前，索引写入系统就已经在工作了。
对于网络搜索引擎，例如 Google、Baidu，这部分是爬虫、pageRank 等工作完成的地方；
对于业务搜索系统，这里是接收业务数据并落库的部分。

## 索引设计

设计一个索引的基本思路是对每个字段进行分析，判断其所需的策略：
- 判断该字段是用于筛选的字段还是用于搜索的字段？
- 该字段是数字还是文本？
- 如果是文本，是否需要支持搜索？
- 如果需要支持搜索，使用哪些搜索策略？

其中搜索策略上文召回部分已经列举了，此处不再赘述。
通常每一种召回策略对应 ES 字段中的一个 field，下面是一个示例 mapping 仅供参考。

```json
{
  "mappings": {
    "dynamic": "false",
    "properties": {
      "name": {
        "type": "text",
        "analyzer": "analyzer_standard_special_char",
        "fields": {
          "cn": {
            "ik": {
              "analyzer": "analyzer_ik",
              "type": "text"
            },
            "keyword": {
              "analyzer": "analyzer_keyword",
              "type": "text"
            },
            "ngram": {
              "analyzer": "analyzer_standard_edgengram_1_20",
              "type": "text"
            }
          },
          "en": {
            "type": "text",
            "analyzer": "analyzer_standard_special_char",
            "fields": {
              "ik": {
                "analyzer": "analyzer_ik",
                "type": "text"
              },
              "keyword": {
                "analyzer": "analyzer_keyword",
                "type": "text"
              },
              "ngram": {
                "analyzer": "analyzer_standard_edgengram_1_20",
                "type": "text"
              }
            }
          },
          "pinyin": {
            "type": "text",
            "analyzer": "analyzer_whitespace"
          }
        }
      },
      "update_time_db": {
        "format": "yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis",
        "type": "date"
      },
      "update_time_es": {
        "format": "yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis",
        "type": "date"
      }
    }
  }
}
```

## 写链路

写入流程属于写数据链路，故放在最后统一阐述。

读链路相比写链路简单很多，主要有如下这些步骤：

1. 接收实体变更事件，依赖于 DB binlog 或业务系统推送
2. 触发实体更新后获取实体最新数据
3. 数据后处理
4. 写入索引

# 合规问题


